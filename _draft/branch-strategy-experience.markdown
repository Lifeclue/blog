---
layout: post
title: "브랜치 전략 경험 기록"
date: "2019-11-15 10:00:00 +0900"
comments: true
---

브랜치 전략 사용 경험을 기록하고 공유하며 나중에 스스로를 돌아보는 데에 읽어보려 합니다.

## Gitflow

2018년 저는 팀에서 하나의 프로젝트를 온전히 도맡아 운영하였습니다. 이때 적용한 것이 깃플로우(Gitflow)였습니다. 당시에는 깃(Git)을 혼자
관리하였지만 나름 깃플로우를 지켜나갔습니다.

종종 옆 프로젝트의 리팩터링(Refactoring)을 돕기도 하였는데 그 프로젝트에도 깃플로우를 전파해 보았습니다. 흐름은 다음과 같습니다.

### 기능 개발

개발(Develop) 브랜치에서 기능(Feature) 브랜치를 생성하여 자윺롭게 개발합니다. 개발한 소스는 개발 브랜치로 PR하며 다른 팀원의 검수를 받아야 하므로
PR의 크기를 잘 조절해야 했고, PR의 크기를 잘 조절하기 위해 기능 브랜치 관리를 기본적으로 해야 합니다.

검수가 끝난 PR은 개발 브랜치로 병합(Merge)되고 개발 브랜치는 개발 환경으로 배포됩니다. 개발 브랜치는 언제든 개발 환경으로 배포될 수 있습니다.

### QA 단계

배포하고 싶은 커밋(Commit)(보통은 개발 브랜치의 HEAD)으로부터 출시(Release) 브랜치를 생성하고 이를 QA 환경에 배포합니다. QA 결과에 따라
수정이 필요하다면 출시 브랜치에 수정 커밋합니다. 

출시가 정해지면 이를 마스터(Master) 브랜치에 PR하며 관련된 팀원들의 검수를 받습니다. 이 단계에서는 필요시 팀원들과 하나의 모니터를 보면서 옆에서
함께 검수하기도 합니다.

이 단계에서도 언제든 개발 브랜치로부터 기능 브랜치를 생성하여 기능 개발을 이어갈 수 있습니다.

### 출시 단계

이 단계는 단순하지만 의견이 분분할 수 있습니다. 출시 브랜치를 마스터 브랜치로 병합하여 배포합니다. 먼저 출시 브랜치를 마스터 브랜치로 어떻게
병합할 것이냐는 물음이 있을 수 있습니다. 이는 PR을 이용할 수도 있지만 누군가 한명이 병합하고 푸시(Push)할 수도 있습니다. 다른 하나는
출시 브랜치를 배포할 것인지 병합된 마스터 브랜치를 배포할 것인지 선택하는 것입니다. 이는 생각보다 간단할 수 있는데, 출시 브랜치는 그 기원이
개발 브랜치에 있다는 것을 상기하시면 됩니다. 병합된 마스터 브랜치는 그 기원이 마스터 브랜치입니다.

마스터 브랜치에 병합이 됐다면 QA 단계에서 수정된 커밋이 있을 수 있으므로 개발 브랜치에도 병합해줍니다.

팀에서는 역시 태그그(Tag)를 사용했는데, 병합된 마스터 브랜치의 병합 커밋에 태그하였습니다.

### 긴급 수정 단계

긴급 수정(Hotfix)이 필요한 경우 Master의 마지막 병합 커밋(배포된 버전)의로부터 긴급 수정 브랜치를 생성하며 코드를 수리한 후 마스터 브랜치로
PR합니다. 또는 긴급한 정도에 따라 PR을 생략할 수 있을 것 같습니다. 마스터 브랜치로 병합되면 출시/배포하고 태그를 달아둡니다. 또한 이 브랜치는
개발 브랜치에도 병합됩니다.

### 장단점

단계가 명확하여 혼란이 있거나 의견이 갈리는 일이 현저히 적었던 것 같습니다. 달리 말하면, 각 업무 단계에서 어떤 전략을 사용해야 하는지 명확했던
것 같습니다.
 
 또한 코드 병합 흐름을 단 방향으로 볼 수 있는데 이것이 깃플로우를 단순하게 유지해주는 것이 아닌가 싶습니다. 자세히 말하자면
 
 ```
 개발 브랜치 -생성-> 기능 브랜치 -병합-> 개발 브랜치 -생성-> 출시 브랜치 -병합-> 마스터 브랜치
```

의 단계로 흘러갑니다. 물론 출시 브랜치의 수정 커밋이나 긴급 수정같은 예외 사항이 있어서 이때 개발 브랜치로의 병합을 놓치면 코드 충돌로 이어집니다.

- 각 단계가 명확하다
- 예외 사항은 있지만 흐름이 단방향이다
- 예외 사항을 신경쓰지 않으면 개발 브랜치에서 코드 충돌이 발생할 수 있다.
- QA와 출시 단계에서 속도가 느려질 수 있다.

## Master is master (초안)

2019년 새로운 팀에서는 마스터 브랜치 전략을 수립하여 사용해 보았습니다.

마스터를 개발 환경에도 쓰고 운영 환경에도 쓰다보니 개발 환경은 마스터의 HEAD, 운영 환경에는 마스터의 태그, 긴급 수정은 마스터로 머지되지 않은
브랜치의 HEAD 이렇다보니 긴급 수정 브랜치가 언제 생성됐냐에 따라 운영 환경에 배포된 버전을 건너 뛸 소지가 있습니다.